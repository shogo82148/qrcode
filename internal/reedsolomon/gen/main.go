package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
)

// polynomial: x^8 = x^4 + x^3 + x^2 + 1
const g = 1<<8 + 1<<4 + 1<<3 + 1<<2 + 1

var expTable [256]element
var logTable [256]int

// element is GF(2^8) performed modulo x^8 + x^4 + x^3 + x^2 + 1.
type element uint8

const zero = element(0)
const one = element(1)

// add returns x + y.
func add(x, y element) element {
	return x ^ y
}

// AddMul sets v = x + y * a^z
func (v *element) AddMulExp(x, y element, z int) {
	if y == zero {
		*v = x
		return
	}
	yz := (logTable[y] + z) % 255
	*v = add(x, expTable[yz])
}

func main() {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by gen/main.go; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package reedsolomon")
	fmt.Fprintln(&buf, "import \"hash\"")

	precomputeTable(&buf)
	precomputeCoefficients(&buf)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("generated.go", out, 0o644); err != nil {
		log.Fatal(err)
	}
}

func precomputeTable(buf *bytes.Buffer) {
	fmt.Fprintln(buf, "// expTable is pre-computed value of expTable[n] = a^n performed modulo x^8 + x^4 + x^3 + x^2 + 1.")
	fmt.Fprintln(buf, "var expTable = [256]element{")
	var v uint = 1
	for i := 0; i < 16; i++ {
		for j := 0; j < 16; j++ {
			fmt.Fprintf(buf, "0x%02x,", v)
			if i*16+j < 255 {
				logTable[v] = i*16 + j
				expTable[i*16+j] = element(v)
			}
			v <<= 1
			v ^= (v >> 8) * g
		}
		fmt.Fprintln(buf)
	}
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "// expTable is pre-computed value of a^logTable[n] = n performed modulo x^8 + x^4 + x^3 + x^2 + 1.")
	fmt.Fprintln(buf, "var logTable = [256]int{ // uint8 is enough, however it is int because avoid to overflow during calculation")
	for i := 0; i < 16; i++ {
		for j := 0; j < 16; j++ {
			fmt.Fprintf(buf, "0x%02x,", logTable[i*16+j])
		}
		fmt.Fprintln(buf)
	}
	fmt.Fprintln(buf, "}")
}

func precomputeCoefficients(buf *bytes.Buffer) {
	fmt.Fprintf(buf, "var coders = [...]func() hash.Hash {\n")
	fmt.Fprintf(buf, "nil,\n")
	fmt.Fprintf(buf, "nil,\n")
	for i := 2; i <= 68; i++ {
		fmt.Fprintf(buf, "new%d,\n", i)
	}
	fmt.Fprintf(buf, "}\n")

	for i := 2; i <= 68; i++ {
		coef := make([]element, i+1)
		coef[0] = one
		for j := 0; j < i; j++ {
			for k := i; k >= 1; k-- {
				coef[k].AddMulExp(coef[k], coef[k-1], j)
			}
		}

		fmt.Fprintf(buf, "type coder%d [%d]element\n", i, i)

		// new
		fmt.Fprintf(buf, "func new%d() hash.Hash { return &coder%d{} }\n\n", i, i)

		// func Reset()
		fmt.Fprintf(buf, "func (c *coder%d) Reset() { for i := range c { c[i] = 0 } }\n", i)

		// func Size()
		fmt.Fprintf(buf, "func (c *coder%d) Size() int { return len(c) }\n", i)

		// func BlockSize()
		fmt.Fprintf(buf, "func (c *coder%d) BlockSize() int { return len(c) }\n", i)

		fmt.Fprintf(buf, "func (c *coder%d) Write(p []byte) (int, error) {\n", i)
		fmt.Fprintf(buf, "for _, b := range p {\n")
		fmt.Fprintf(buf, "if c[0] == 0 {\n")
		fmt.Fprintf(buf, "copy(c[0:], c[1:])\n")
		fmt.Fprintf(buf, "c[%d] = element(b)\n", i-1)
		fmt.Fprintf(buf, "continue\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "x := logTable[c[0]]\n")
		for j, a := range coef[1:i] {
			fmt.Fprintf(buf, "c[%d].AddMulExp(c[%d], x, %d)\n", j, j+1, logTable[a])
		}
		fmt.Fprintf(buf, "c[%d].AddMulExp(element(b), x, %d)\n", i-1, logTable[coef[i]])
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return len(p), nil\n")
		fmt.Fprintf(buf, "}\n")

		// func Sum(buf []byte)
		fmt.Fprintf(buf, "func (c coder%d) Sum(buf []byte) []byte {\n", i)
		fmt.Fprintf(buf, "c.Write(buf)\n")
		fmt.Fprintf(buf, "if cap(buf) < %d {\n", i)
		fmt.Fprintf(buf, "buf = make([]byte, %d)\n", i)
		fmt.Fprintf(buf, "} else {\n")
		fmt.Fprintf(buf, "buf = buf[:%[1]d]\n", i)
		fmt.Fprintf(buf, "for i := range buf {\n buf[i] = 0\n}\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "c.Write(buf)\n")
		fmt.Fprintf(buf, "for i := range buf {\n")
		fmt.Fprintf(buf, "buf[i] = byte(c[i])\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return buf\n")
		fmt.Fprintf(buf, "}\n")
	}
}
