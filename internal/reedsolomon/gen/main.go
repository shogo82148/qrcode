package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
)

// polynomial: x^8 = x^4 + x^3 + x^2 + 1
const g = 1<<8 + 1<<4 + 1<<3 + 1<<2 + 1

var expTable [256]element
var logTable [256]int

// element is GF(2^8) performed modulo x^8 + x^4 + x^3 + x^2 + 1.
type element uint8

const zero = element(0)
const one = element(1)

// add returns x + y.
func add(x, y element) element {
	return x ^ y
}

// AddMul sets v = x + y * a^z
func (v *element) AddMulExp(x, y element, z int) {
	if y == zero {
		*v = x
		return
	}
	yz := (logTable[y] + z) % 255
	*v = add(x, expTable[yz])
}

func main() {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by gen/main.go; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package reedsolomon")
	fmt.Fprintln(&buf, "import (")
	fmt.Fprintln(&buf, "\"hash\"")
	fmt.Fprintln(&buf, "\"github.com/shogo82148/qrcode/internal/reedsolomon/element\"")
	fmt.Fprintln(&buf, ")")

	precomputeTable()
	precomputeCoefficients(&buf)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("table_gen.go", out, 0o644); err != nil {
		log.Fatal(err)
	}
}

func precomputeTable() {
	var v uint = 1
	for i := 0; i < 255; i++ {
		logTable[v] = i
		expTable[i] = element(v)
		v <<= 1
		v ^= (v >> 8) * g
	}
}

func precomputeCoefficients(buf *bytes.Buffer) {
	fmt.Fprintf(buf, "var coders = [...]func() hash.Hash {\n")
	fmt.Fprintf(buf, "nil,\n")
	fmt.Fprintf(buf, "nil,\n")
	for i := 2; i <= 68; i++ {
		fmt.Fprintf(buf, "new%d,\n", i)
	}
	fmt.Fprintf(buf, "}\n")

	for i := 2; i <= 68; i++ {
		coef := make([]element, i+1)
		coef[0] = one
		for j := 0; j < i; j++ {
			for k := i; k >= 1; k-- {
				coef[k].AddMulExp(coef[k], coef[k-1], j)
			}
		}

		fmt.Fprintf(buf, "type coder%d [%d]element.Element\n", i, i)

		// new
		fmt.Fprintf(buf, "func new%d() hash.Hash { return &coder%d{} }\n\n", i, i)

		// func Reset()
		fmt.Fprintf(buf, "func (c *coder%d) Reset() { for i := range c { c[i] = 0 } }\n", i)

		// func Size()
		fmt.Fprintf(buf, "func (c *coder%d) Size() int { return len(c) }\n", i)

		// func BlockSize()
		fmt.Fprintf(buf, "func (c *coder%d) BlockSize() int { return len(c) }\n", i)

		fmt.Fprintf(buf, "func (c *coder%d) Write(p []byte) (int, error) {\n", i)
		fmt.Fprintf(buf, "for _, b := range p {\n")
		fmt.Fprintf(buf, "if c[0] == 0 {\n")
		fmt.Fprintf(buf, "copy(c[0:], c[1:])\n")
		fmt.Fprintf(buf, "c[%d] = element.Element(b)\n", i-1)
		fmt.Fprintf(buf, "continue\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "x := element.Log(c[0])\n")
		for j, a := range coef[1:i] {
			fmt.Fprintf(buf, "c[%d] = element.AddMulExp(c[%d], x, %d)\n", j, j+1, logTable[a])
		}
		fmt.Fprintf(buf, "c[%d] = element.AddMulExp(element.Element(b), x, %d)\n", i-1, logTable[coef[i]])
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return len(p), nil\n")
		fmt.Fprintf(buf, "}\n")

		// func Sum(buf []byte)
		fmt.Fprintf(buf, "func (c coder%d) Sum(buf []byte) []byte {\n", i)
		fmt.Fprintf(buf, "c.Write(buf)\n")
		fmt.Fprintf(buf, "buf = buf[:%d]\n", i)
		fmt.Fprintf(buf, "for i := range buf {\n")
		fmt.Fprintf(buf, "buf[i] = 0\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "c.Write(buf)\n")
		fmt.Fprintf(buf, "for i := range buf {\n")
		fmt.Fprintf(buf, "buf[i] = byte(c[i])\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return buf\n")
		fmt.Fprintf(buf, "}\n")
	}
}
